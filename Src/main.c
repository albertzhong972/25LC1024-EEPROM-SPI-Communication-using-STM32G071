/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/*
 * Written by Albert Zhong
 * Purpose: Communicate with 25LC1024 EEPROM chip using SPI
 *
 * */

#include <../Inc/stm32g071xx.h>
#include "uart.h"
#include "spi.h"

//25LC1024 EEPROM instructions
#define  READ    0x03          //  READ instruction
#define  WRITE   0x02          //  WRITE instruction
#define  WREN    0x06          //  WRITE ENABLE instruction
#define  RDSR    0x05          //  READ STATUS register instruction
#define  WRSR    0x01          //  WRITE STATUS REGISTER instruction
#define  NOPROT  0x00          //  disable all write protections
#define  PGSZ    0x10          //  size of PAGE = 16 bytes
#define  MAXLEN  0x70          //  maximum length of a string = 128 bytes

//char writebuffer[50];
char uart;
char status;
char page_buffer[256]; //max bytes per page


void READ_STATUS(void)
{

	SPI1_Enable();
	SPI1_SendChar(RDSR); // send RDSR instruction
	status = SPI1_ReadChar();
	SPI1_Disable();
}

void WRITE_ENABLE(void) {
	SPI1_Enable();
	SPI1_SendChar(WREN);	//send write enable instruction
	SPI1_Disable();
}

void EEPROM_WRITE(int addr, char data) {
	SPI1_Enable();

	SPI1_SendChar(WRITE);	//send write instruction
	SPI1_SendChar(addr >> 16);	//MSB of 24 bit addr
	SPI1_SendChar((addr >> 8) & 0xFF);
	SPI1_SendChar(addr & 0xFF);
	SPI1_SendChar(data); //send data

	SPI1_Disable();

}

void EEPROM_WRITE_PAGE(int addr, char* data) {
	SPI1_Enable();

	SPI1_SendChar(WRITE);	//send write instruction
	SPI1_SendChar(addr >> 16);	//MSB of 24 bit addr
	SPI1_SendChar((addr >> 8) & 0xFF);
	SPI1_SendChar(addr & 0xFF);
	SPI1_SendString(data); //send data

	SPI1_Disable();

}

char EEPROM_READ(int addr) {


	SPI1_Enable();

	SPI1_SendChar(READ);	//send read instruction
	SPI1_SendChar(addr >> 16);	//MSB of 24 bit addr
	SPI1_SendChar((addr >> 8) & 0xFF);
	SPI1_SendChar(addr & 0xFF);
	uart = SPI1_ReadChar();

	SPI1_Disable();
	return uart;
}

//Read multiple bytes of data
char* EEPROM_READ_PAGE(int addr, int size) {

	for(int i = 0; i < size; i++)
	{
		page_buffer[i] = EEPROM_READ(addr + i);
	}

	return page_buffer;
}

int main(void)
{
	//uartbuffer = 0;
	UART_Config();
	SPI1_Config();
	int pressed = 0;

	while(1)
	{
		if(!((GPIOC -> IDR) & 0x2000) && pressed == 0)	//When button at PC13 is pressed, send SPI string
		{

			WRITE_ENABLE();
			READ_STATUS();

			UART_SendString("Writing.... \r\n");
			EEPROM_WRITE_PAGE(0, "Albert Zhong");

			UART_SendString("Reading.... \r\n");
			UART_SendString(EEPROM_READ_PAGE(0, 12));

			pressed = 1;
		}

	}
}
